// -*- mode: c++ -*-
#ifndef COMMANDLINEGArgument_H
#define COMMANDLINEGArgument_H

/***************************************************************************
***          Author: Per Thomas Hille <pth@embc.no>                     ****
****************************************************************************/

/****************************************************************************
*** Copyright(C) 2018  Per Thomas Hille, pth@embc.no                      ***
*** This file is part of logmaster.logmaster is free software : you can   ***
*** redistribute it and / or modify it under the terms of the Lesser GNU  ***
*** General Public License(LGPL) V3 or later.See.cpp file for details     ***
*****************************************************************************/

#pragma once

#include "GArgument.h"

#include <utilities/GDataTypes.h>
#include <utilities/GDefinitions.h>

#include <logging/LLogApi.h>
#include <logging/LLogging.h>
#include <logging/LPublisher.h>

#include <vector>
#include <iostream>
#include <typeinfo>
#include <stdio.h>
#include <string.h>
#include <sstream>
#include <type_traits>

using namespace LOGMASTER;
using namespace std;


/** @brief base class for all command line arguments */
template <typename T>
class GCommandLineArgument : public GArgument
{

public:

    /** Main constructor.
    * @param  name    the identifier of the command line argument, i.e the identifier used on the command line  
    * @param  usage    short description of the usage of the parameter.
    * @param  helptxt more elaborate description of the usage of the parameter
    * @tparam T  The type of the argument value
    * @param  arg     a pointer to the variable to be scanned from the command line. It can be a zero pointer in which case no value is read from the command line
    * @param  ismandatory  whether or not a parameter is mandatory, If a command line argument is marked as mandatory, and it is not present on the command line, then the command line handling system will throw an exception.
    * @param  funct An optional validation function. It takes as an argument the command line tag (referenced by the variable "name" ) and a vector of sub commands (sub) and  parameters (par). The vector
    * of subcommand and parameters are automatically generated by the system. The function pointer can be a zero pointer in which case no validation check is performed. */
    GCommandLineArgument(    const string &name, const string &usage, const string &helptxt, T *arg, const bool ismandatory =false, 
                                std::function< bool(const string cmnd, const string args_s, const vector<string> sub, const vector<string> par)> funct = 0) : 
                                GArgument(name,
                                usage,   
                                helptxt,
                                ismandatory,
                                funct),
                                fParameter(arg)
    {
                SetTypeId();
    }


    GCommandLineArgument(const string name, T *arg,  const bool ismandatory  = false) : GCommandLineArgument(name, "", "", arg, ismandatory, 0)
    {

    }


    virtual ~GCommandLineArgument() override;
    virtual void * GetParameter() { return fParameter; }
    void    SetTypeId();
    void    SetParameter (T *par);
    void    SetParameterF(T *par);
    void    SetParameterVal_t(double *par);
    virtual string str() const;

protected:
    T *fParameter = nullptr;

private:
    GCommandLineArgument();
    GCommandLineArgument(const GCommandLineArgument &);
    GCommandLineArgument  & operator = (const GCommandLineArgument  &  rhs)
    {
         fParameter = reinterpret_cast<T *>(rhs.GetParameter());
         return *this;
     }
};



template<class T>
inline GCommandLineArgument<T>::~GCommandLineArgument()
{
}



template <class T>
void GCommandLineArgument<T>::SetTypeId()
{
    fTypeId = typeid(T).name();
    if (
        std::is_base_of< Val_t<double>, T >::value ||
        std::is_base_of< Val_t<long double>, T >::value ||
        std::is_base_of< Val_t<float>, T >::value ||
        std::is_base_of< Val_t<short>, T >::value ||
        std::is_base_of< Val_t<int>, T >::value ||
        std::is_base_of< Val_t<long>, T >::value ||
        std::is_base_of< Val_t<long long>, T >::value ||
        std::is_base_of< Val_t<unsigned short>, T >::value ||
        std::is_base_of< Val_t<unsigned int>, T >::value ||
        std::is_base_of< Val_t<unsigned long int>, T >::value ||
        std::is_base_of< Val_t<unsigned char>, T >::value ||
        std::is_base_of< Val_t<char>, T >::value
        //  std::is_base_of< Val_t<uint8_t>, T >::value
        )
    {
        fTypeIdBase = "Val_t";
    }
    else
    {
        fTypeIdBase = "unknown Val_t base type";
    }
}



template <class T>
string GCommandLineArgument<T>::str() const
{
    std::stringstream buffer;  
    buffer << GArgument::str() << endl;
    return buffer.str();    
}


template<class T>
inline void GCommandLineArgument<T>::SetParameter(T * par)
{
    if (par ==  nullptr || fParameter == nullptr )
    {
        G_INFO("Parameter is a ZERO pointer, no assignment possible");
        return;
    }
    else
    {
        if (typeid(T).name() == typeid(string).name())
        {
            *fParameter = *par;
        }
        else
        {
            for (unsigned int i = 0; i < par->size(); i++)
            {
                if (fParameter != 0) {
                    fParameter->push_back((*par)[i]);
                }
                else
                {
                    G_INFO("Argument to parameter %s is a ZERO pointer (this might not be an error), no parameter(s) added", fCmd.c_str());
                }
            }
        }
    }
}



template<class T>
inline void GCommandLineArgument<T>::SetParameterF(T * par)
{
    if (fParameter !=  nullptr )
    {
        T tmp = (T)(*par);
        *fParameter = tmp;
    }
    else
    {
        G_INFO("GArgument is ZERO, nothing added");
    }
}


template<class T>
inline void
GCommandLineArgument<T>::SetParameterVal_t(double *par)
{
    if( par != nullptr )
    {
       fParameter->SetValue(*par);
    }
}    



#endif

