// -*- mode: c++ -*-

/* ****************************************************************************
***          Author: Per Thomas Hille <pth@embc.no>                       ****
***************************************************************************** */

/* ****************************************************************************
******************************************************************************
*** This file is part of logmaster.                                        ***
*** Copyright (C) Per Thomas Hille <pth@embc.no>  http:///www.embc.no      ***
*** all rights reserved                                                    ***
***                                                                        ***
*** logmaster is free software: you can redistribute it and/or modify      ***
*** it under the terms of the Lesser GNU General Public License (LGPL)     ***
*** as published by the Free Software Foundation, either version 3 of the  ***
*** License, or (at your option) any later version.                        ***
***                                                                        ***
*** logmaster is distributed in the hope that it will be useful,           ***
*** but WITHOUT ANY WARRANTY; without even the implied warranty of         ***
*** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          ***
*** GNU General Public License for more details.                           ***
***                                                                        ***
*** You should have received a copy of the Lesser GNU General Public       ***
*** License along with logmaster in the README file in the source code     ***
*** directory. If not, see <http://www.gnu.org/licenses/>.                 ***
******************************************************************************
******************************************************************************/


#include "TestReferenceData.h"

#include <configurator/LGeneratorMacrosException.h>
#include <configurator/LGeneratorMacrosLogging.h>
#include <configurator/LGeneratorEnum.h>
#include <configurator/LGeneratorHashMap.h>
#include <configurator/LGeneratorLogTest.h>
#include <configurator/LXmlParser.h>


#include <utilities/GDefinitions.h>

#include <logging/LLogApi.h>
using namespace LOGMASTER;


///    LGenerator::DisableSuffix( );

string  TestReferenceData::fTestDataDir = "";
// string  TestReferenceData::fXMLPath = "";
// string  TestReferenceData::fXSDPath = "";
// std::shared_ptr<LXMLInfo>  TestReferenceData::fXMLInfo = nullptr;
sysentity_vec    TestReferenceData::fSubSystems;
logentity_vec  TestReferenceData::fLogLevels;

using namespace CONFIGURATOR;

#define MINIMUM_EXPECTED_LINES 40



void TestReferenceData::SetUpTestCase()
{
#ifdef _WIN32
    /** @todo There must be a better way to do this */
	string s = string(EXPAND(LOGMASTER_HOME));
	s.erase(0,1);
	s.erase(s.size() -2 );
	fTestDataDir = s +  string("reference-data\\");

#else
	/** @todo Implement for Linux */
#endif
    /** @todo this parser should take LXMLInfoStruct as input*/
    LXmlParser( ).ParseXML( gXMLPath, gXSDPath, fLogLevels, fSubSystems);
    
    CERR << "testdir = " << fTestDataDir << ENDL;
}


/**
TEST_F(TestReferenceData, ok)
{
    SUCCEED( );
}
*/

#define NO_SUFFIX false


INSTANTIATE_TEST_CASE_P(
    Compare,
    TestReferenceData,
    ::testing::Values(
          TestParameters(std::make_shared<LGeneratorMacrosException>("", "tmp.txt", gXMLInfo, NO_SUFFIX), "GExceptionAutoGen.h", 30),
        TestParameters(std::make_shared<LGeneratorMacrosLogging>("", "tmp.txt", gXMLInfo, NO_SUFFIX), "LLogApiAutoGen.h", 30),
        TestParameters(std::make_shared<LGeneratorEnum>("", "tmp.txt", gXMLInfo, NO_SUFFIX), "LEnumAutoGen.h", 30),
        TestParameters(std::make_shared<LGeneratorHashMap>("", "tmp.txt", gXMLInfo, NO_SUFFIX), "LHashMapsAutoGen.cpp", 30),
        TestParameters(std::make_shared<LGeneratorLogTest>("", "tmp.txt", gXMLInfo, NO_SUFFIX), "LLogTestAutoGen.cpp", 30)));


/*
TEST_P(TestReferenceData, OK)
{
    SUCCEED( );
}
*/


void TestReferenceData::TearDownTestCase()
{
	//CERR << "TEARDOWN" << ENDL;
}



TEST_P(TestReferenceData, exists_xml)
{
    ASSERT_TRUE(g_system( )->Exists(gXMLPath)) << gXMLPath;
}


TEST_P(TestReferenceData, exists_xsd)
{
    ASSERT_TRUE(g_system( )->Exists(gXSDPath)) << gXSDPath;
}



/** Compare generated file content with reference data
* line by line. We accept typically 3 lines with errors.
* The time stamp, the location of the XML + XSD file. All the
* rest should be identical. 
* @param ref Reference data read from file
* @param gen The data generated by the test
* @param max_errors  The maximum number of lines that can differ.
* Default is 3 */
void 
TestReferenceData::Compare(const int max_errors)
{
   

    ASSERT_TRUE(fReferenceData.size( ) == fGeneratedData.size( ));
    ASSERT_TRUE(fReferenceData.size() > MINIMUM_EXPECTED_LINES);
    int n_eq = 0; // number of lines that is equal
    int n_neq = 0; // number of lines that are identical

    for ( size_t i = 0; i < fGeneratedData.size( ); i++ )
    {
        if ( fGeneratedData.at(i) == fReferenceData.at(i) ) {
            n_eq++;
        }
        else {
          //  FORCE_DEBUG("%s", fGeneratedData.at(i).c_str() );
          //  FORCE_DEBUG("%s\n\n", fReferenceData.at(i).c_str());

            n_neq++;
        }
    }

    CERR << "n_eq =  " << n_neq << ENDL;

    EXPECT_TRUE( n_neq <= max_errors);

};




TEST_P(TestReferenceData, Compare)
{
    auto t = GetParam( );
    // string filename = "foo.txt";
    GenerateData(t.fFileame, t.fGenerator);
    
    
    CERR << "size1 = " << fGeneratedData.size( ) << ENDL;
    CERR << "size1 = " << fReferenceData.size( ) << ENDL;
   

    ASSERT_TRUE(fReferenceData.size( ) == fGeneratedData.size( ));
    
    
    
    ASSERT_TRUE(fReferenceData.size( ) > MINIMUM_EXPECTED_LINES);
    int n_eq = 0; // number of lines that is equal
    int n_neq = 0; // number of lines that are identical

    for ( size_t i = 0; i < fGeneratedData.size( ); i++ )
    {
        if ( fGeneratedData.at(i) == fReferenceData.at(i) ) {
            n_eq++;
        }
        else {
            //  FORCE_DEBUG("%s", fGeneratedData.at(i).c_str() );
            //  FORCE_DEBUG("%s\n\n", fReferenceData.at(i).c_str());

            n_neq++;
        }
    }
    
    CERR << "n_eq =  " << n_neq << ENDL;
    EXPECT_TRUE(n_neq <= t.fMaxErrors );
    
}






/*
TEST_F(TestReferenceData, exception_macros)
{
    try
    {
        GenerateData<LGeneratorMacrosException>("GExceptionAutoGen.h");
        Compare();
    }
    catch (GException& e)
    {
        FAIL() << e.what();
    }
    catch (std::exception& e)
    {
        FAIL() << e.what();
    }
}
*/


/*
TEST_F(TestReferenceData, logging_macros)
{
    GenerateData<LGeneratorMacrosLogging>("LLogApiAutoGen.h");
    Compare(10);
}


TEST_F(TestReferenceData, enums)
{
    GenerateData<LGeneratorEnum>("LEnumAutoGen.h");
    Compare(20);
}


TEST_F(TestReferenceData, hashmaps)
{
    GenerateData<LGeneratorHashMap>("LHashMapsAutoGen.cpp");
    Compare(30);// This file will have more different line because the class name is derived from the filename
}


TEST_F(TestReferenceData, logtest)
{
    GenerateData<LGeneratorLogTest>("LLogTestAutoGen.cpp");
    Compare(5);
}
*/

