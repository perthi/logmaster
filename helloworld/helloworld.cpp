// -*- mode: c++ -*-

// #include <configurator/LXmlParser.h>
// #include <xml/GXmlValidator.h>
// #include <configurator/LFileCreator.h>
/// #include <configurator/LArgumentScanner.h>
// #include <logging/LLogApi.h>
// #include <utilities/version-info/GMenu.h>
// #include <logging/GException.h>
// #include <configurator/LGeneratorTestLHashMaps.h>
//#include <logging/LPublisher.h>
#include <utilities/GFormatting.h>

using namespace GFormatting;

//#include <fmt/format.h>

#ifdef _W_IN32
#include <Windows.h>
#endif

//#include <string>
//using std::string;
//using namespace LOGMASTER;
//using namespace CONFIGURATOR;

template<typename...  Args>
void print_values(const Args&... args) 
{
    // This lambda is a common way to expand and process parameter packs
     const Arg argArray[] = {args...};
     printf("size = %ld\n", sizeof ...(Args) );
    // printf((int)argArray.type); 
    for (uint64_t i=0; i  <  sizeof ...(Args) ; i++)
    {
        printf("type = %d\n", (int)argArray[i].type);
    }  


     /*
     ([&](const auto& arg){
        std::cout << arg << " ";
    }(args), ...); // The comma operator combined with pack expansion
    std::cout << std::endl;
   */
}

int main() {
    int i = 10;
    std::string s = "hello";
    double d = 3.14;
 //    print_values("i = %d", i);
    print_values("i = %d, i2 = %d, s= %s, d = %f", i, i, s.c_str(), d);
  //  print_values(i, s, d); // Pass by const reference
  //  print_values(5, "world"); // Literals can also be passed
    
    // Attempting to modify 'i' within print_values would result in a compile-time error
    // (e.g., if print_values tried to do `arg = 20;` for an int)

    return 0;
}






/*
int main(int  argc, const char** argv)
{

    try
    {
        XML_EXCEPTION("Testing new exception");

    }
    catch ( std::exception& e )
    {
        CERR << e.what( ) << ENDL;
    }


    GMenu::Instance( )->ScanArguments(argc, argv);
    LPublisher::Instance( )->SetMode(ePUBLISH_MODE::SYNCHRONOUS);    

    try
    {
        string xml = "";
        string xsd = "";
        auto xml_args = LArgumentScanner().GenerateArgs(xml, xsd);

        GLogApplication( ).InitLogArgs( ).AddArguments(xml_args).ScanArguments( argc, argv);

        XML_ASSERT_EXCEPTION(GXmlValidator( ).IsValid(xml, xsd), "failed to validate %s against %s", xml.c_str( ), xsd.c_str( ));
        logentity_vec  loglevels;
        sysentity_vec  subsystems;
        LXmlParser( ).ParseXML( LXMLInfo(xml, xsd), loglevels, subsystems);
        XML_INFO("Successfully validated %s against %s and parsed the XML file", xml.c_str( ), xsd.c_str( ));
        auto l_system =  std::make_shared<LGeneratorTestLHashMaps>("logging/unit-tests/commit/", "TestHashMapsAutoGenerated", (LXMLInfo(xml, xsd)));
        LFileCreator( ).GenerateSingleFile(l_system, loglevels, subsystems);

    }
    catch ( const GException& e )
    {
        std::cerr << e.what( ) << endl;
    }
    catch ( const std::exception& e )
    {
        std::cerr << e.what( ) << endl;
    }
    catch ( const std::string& e )
    {
        std::cerr << e << endl;
    }
    catch ( ... )
    {
        FORCE_DEBUG("Unknown exception caught ....");
    }

}
*/
